// Global variables for report settings
let selectedReportType = '';
let selectedMainType = '';
let userCurrency = 'R';

// Add to the top of the file
// Add a synchronous version of getItem for use in functions that can't be async
mobileStorage.getItemSync = function(key) {
    // Try to get from localStorage first (for backward compatibility)
    if (typeof localStorage !== 'undefined') {
        const value = localStorage.getItem(key);
        if (value) return value;
    }
    
    // For mobileStorage, we need to use a sync version
    // Since we're in a sync function, we'll return the last known value or default
    // This is a compromise but should work for most cases
    return this._cache?.[key] || null;
};

// Initialize cache to store values for sync access
mobileStorage._cache = {};

// Override the original getItem to update cache
const originalGetItem = mobileStorage.getItem;
mobileStorage.getItem = async function(key) {
    const value = await originalGetItem.call(this, key);
    // Update cache
    if (!this._cache) this._cache = {};
    this._cache[key] = value;
    return value;
};

document.addEventListener('DOMContentLoaded', async () => {
    // Check if logged in
    const isLoggedIn = await mobileStorage.getItem('isLoggedIn');
    if (isLoggedIn !== 'true') {
        window.location.href = 'index.html';
        return;
    }
    
    // Setup keyboard detection for mobile devices
    setupKeyboardDetection();
    
    // Initialize state
    // let selectedReportType = '';  // Moved to global scope
    // let selectedMainType = '';    // Moved to global scope
    userCurrency = await mobileStorage.getItem('currency') || 'R';
    
    // Set default dates (last 30 days)
    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);
    document.getElementById('date-from').value = thirtyDaysAgo.toISOString().split('T')[0];
    document.getElementById('date-to').value = today.toISOString().split('T')[0];
    
    // Set up debug panel
    setupDebugPanel();
    
    // Set up orientation change handling
    window.addEventListener('orientationchange', handleOrientationChange);
    
    // Add event listeners
    setupEventListeners();
    
    // Initialize currency format - fix error with invalid currency code
    // Store the currency symbol for display
    const currencySymbol = typeof userCurrency === 'string' ? userCurrency.trim() : 'R';
    
    // For Intl.NumberFormat, we need an ISO currency code, not just a symbol
    // Map common symbols to ISO codes or default to USD
    let currencyCode = 'ZAR'; // Default to ZAR instead of USD
    
    // Define the formatter at the global scope so it's accessible everywhere
    let currencyFormatter;
    
    try {
        console.log('User currency value:', userCurrency);
        
        if (typeof userCurrency === 'string') {
            const currencyMap = {
                '$': 'USD',
                '£': 'GBP',
                '€': 'EUR',
                '¥': 'JPY',
                '₹': 'INR',
                'R': 'ZAR',
                'R$': 'BRL'
            };
            
            const trimmedCurrency = userCurrency.trim();
            console.log('Trimmed currency symbol:', trimmedCurrency);
            
            // Only use the mapped value if it exists in our map
            if (currencyMap[trimmedCurrency]) {
                currencyCode = currencyMap[trimmedCurrency];
                console.log('Mapped to ISO code:', currencyCode);
            } else {
                // If not in our map but looks like a valid ISO code (3 letters), use it
                if (/^[A-Z]{3}$/.test(trimmedCurrency)) {
                    currencyCode = trimmedCurrency;
                    console.log('Using currency as ISO code:', currencyCode);
                } else {
                    console.log('Using default ZAR code');
                }
            }
        }
        
        // Create the formatter with a guaranteed valid ISO currency code
        console.log('Final currency code for formatter:', currencyCode);
        
        currencyFormatter = new Intl.NumberFormat(undefined, {
            style: 'currency',
            currency: currencyCode,
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
    } catch (e) {
        console.error('Error creating currency formatter:', e);
    }
    
    // Define the formatCurrency function to handle fallback scenarios
    function formatCurrency(amount) {
        if (amount === undefined || amount === null) return `R0.00 ZAR`;
        
        try {
            // Format currency in the requested style: "R187500.00 ZAR"
            const numAmount = Number(amount);
            const formattedAmount = numAmount.toFixed(2);
            return `R${formattedAmount} ZAR`;
        } catch (e) {
            console.error('Error formatting currency:', e);
            // Fallback to simple formatting if formatting fails
            return `R${Number(amount).toFixed(2)} ZAR`;
        }
    }
    
    // Expose formatCurrency to the window object for global access
    window.formatCurrency = formatCurrency;
    
    function setupKeyboardDetection() {
        // For iOS using visual viewport API
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                // The viewport size gets smaller when the keyboard appears
                const currentHeight = window.visualViewport.height;
                const windowHeight = window.innerHeight;
                
                if (currentHeight < windowHeight * 0.8) {
                    // Keyboard is likely visible
                    document.body.classList.add('keyboard-open');
                } else {
                    // Keyboard is likely hidden
                    document.body.classList.remove('keyboard-open');
                }
            });
        } else {
            // Fallback for other devices - use focus/blur events
            document.addEventListener('focusin', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    document.body.classList.add('keyboard-open');
                }
            });
            
            document.addEventListener('focusout', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    // Small delay to prevent flashing during focus changes between inputs
                    setTimeout(() => {
                        if (document.activeElement.tagName !== 'INPUT' && 
                            document.activeElement.tagName !== 'TEXTAREA' && 
                            document.activeElement.tagName !== 'SELECT') {
                            document.body.classList.remove('keyboard-open');
                        }
                    }, 100);
                }
            });
        }
    }
    
    function handleOrientationChange() {
        // Adjust UI for different orientations
        if (window.orientation === 90 || window.orientation === -90) {
            // Landscape mode
            document.querySelector('.date-range')?.classList.add('landscape');
            
            // Adjust table display for landscape
            const reportTables = document.querySelectorAll('.report-table');
            reportTables.forEach(table => {
                table.style.minWidth = "auto";
            });
        } else {
            // Portrait mode
            document.querySelector('.date-range')?.classList.remove('landscape');
            
            // Optimize table display for portrait view - no min-width that forces scrolling
            const reportTables = document.querySelectorAll('.report-table');
            reportTables.forEach(table => {
                table.style.minWidth = "auto";
            });
        }
    }
    
    function setupEventListeners() {
        // Add event listeners for all report type selects
        document.getElementById('animal-report-type')?.addEventListener('change', handleReportTypeChange);
        document.getElementById('feed-report-type')?.addEventListener('change', handleReportTypeChange);
        document.getElementById('health-report-type')?.addEventListener('change', handleReportTypeChange);
        document.getElementById('category-filter')?.addEventListener('change', handleCategoryChange);
        
        // Fix for generate report button - add console log and make sure handler is attached
        const generateReportBtn = document.getElementById('generate-report');
        if (generateReportBtn) {
            console.log('Adding event listener to Generate Report button');
            generateReportBtn.addEventListener('click', handleGenerateReport);
            // Add a direct event for testing
            generateReportBtn.onclick = function() {
                console.log('Generate Report clicked via onclick');
                handleGenerateReport();
            };
        } else {
            console.error('Generate Report button not found in the DOM');
        }
    }
    
    function handleReportTypeChange(event) {
        // Clear other selects
        const reportSelects = ['animal-report-type', 'feed-report-type', 'health-report-type'];
        reportSelects.forEach(id => {
            if (id !== event.target.id && document.getElementById(id)) {
                document.getElementById(id).value = '';
            }
        });
        
        // Set global variables
        selectedReportType = event.target.value;
        selectedMainType = event.target.id.split('-')[0]; // 'animal', 'feed', or 'health'
        
        console.log('Report type changed:', {
            type: selectedReportType,
            mainType: selectedMainType
        });
        
        // Clear any previous report results
        clearPreviousReportResults();
        
        updateCategoryOptions();
    }
    
    function clearPreviousReportResults() {
        // Clear the report content area
        document.querySelector('.report-content').innerHTML = 
            '<div class="empty-state">Select report criteria and click Generate Report</div>';
    }
    
    async function updateCategoryOptions() {
        const categorySelect = document.getElementById('category-filter');
        const categoryHelp = document.querySelector('.help-text');
        
        if (!categorySelect || !categoryHelp) return;
        
        // Clear existing options
        categorySelect.innerHTML = '<option value="all">All Categories</option>';
        
        if (!selectedMainType) {
            categorySelect.disabled = true;
            categoryHelp.textContent = 'Select a report type to see relevant categories';
            return;
        }
        
        try {
            let categories = [];
            
            // Get categories based on main type
            switch (selectedMainType) {
                case 'animal':
                    categories = await getAnimalCategories();
                    categoryHelp.textContent = 'Filter by animal category';
                    break;
                case 'feed':
                    // Get feed categories from storage
                    const feedCategoriesStr = await mobileStorage.getItem('feedCategories');
                    categories = feedCategoriesStr ? JSON.parse(feedCategoriesStr) : [];
                    categoryHelp.textContent = 'Filter by feed type';
                    break;
                case 'health':
                    // Health categories are the same as animal categories
                    categories = await getAnimalCategories();
                    categoryHelp.textContent = 'Filter by animal category';
                    break;
            }
            
            console.log('Retrieved categories:', categories);
            
            // Add categories to select
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option);
            });
            
            // Store the category type to ensure proper filtering
            categorySelect.dataset.categoryType = selectedMainType;
            
            categorySelect.disabled = false;
        } catch (error) {
            console.error('Error updating categories:', error);
            categorySelect.disabled = true;
            categoryHelp.textContent = 'Error loading categories';
        }
    }
    
    function handleCategoryChange() {
        // No automatic report generation
    }
    
    // New simplified implementation for debugging
    async function handleGenerateReport() {
        const reportResults = document.querySelector('.report-content');
        
        try {
            // Clear previous results
            clearPreviousReportResults();
            
            // Show loading state
            reportResults.innerHTML = '<div class="loading">Loading report data...</div>';
            
            // Collect filters
            const filters = collectFilters();
            
            // Validate date range
            const startDate = new Date(filters.dateRange.start);
            const endDate = new Date(filters.dateRange.end);
            
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                reportResults.innerHTML = '<div class="error-message">Please enter valid date range</div>';
                return;
            }
            
            if (startDate > endDate) {
                reportResults.innerHTML = '<div class="error-message">Start date must be before end date</div>';
                return;
            }
            
            // Check if we have a report type selected
            if (!filters.reportType) {
                reportResults.innerHTML = '<div class="error-message">Please select a report type</div>';
                return;
            }
            
            // Collect data based on filters
            const reportData = await collectReportData(filters);
            
            // If no data returned, show message
            if (!reportData || (Array.isArray(reportData) && reportData.length === 0) || 
                (reportData.feedTransactions && reportData.feedTransactions.length === 0 && 
                 filters.reportType !== 'feed-inventory' && filters.reportType !== 'feed-calculation')) {
                reportResults.innerHTML = `<div class="empty-state">No data found for the selected criteria</div>`;
                return;
            }
            
            // Generate report based on type
            let reportHTML = '';
            
            try {
                switch (filters.reportType) {
                    case 'all-feed':
                        reportHTML = createAllFeedReportTable(reportData);
                        break;
                        
                    case 'feed-purchase':
                        reportHTML = createFeedPurchaseTable(reportData);
                        break;
                        
                    case 'feed-usage':
                        reportHTML = createFeedUsageTable(reportData);
                        break;
                        
                    case 'feed-calculation':
                        console.log('Feed calculation case triggered');
                        try {
                            // Direct implementation of feed calculations report
                            const startDate = document.getElementById('date-from').value;
                            const endDate = document.getElementById('date-to').value;
                            
                            console.log('Feed calculations date range:', startDate, 'to', endDate);
                            
                            // Mock feed calculation data based on user's example
                            const feedCalculations = [
                                {
                                    animalType: 'Cull Cows',
                                    count: 1,
                                    date: '3/25/2025',
                                    feedType: 'Production Lick',
                                    dailyIntake: 1.20,
                                    intakeUnit: 'kg',
                                    totalFeed: 144.00,
                                    duration: 120,
                                    dailyCost: 7.68,
                                    costPerAnimal: 7.68,
                                    totalCost: 921.60
                                },
                                {
                                    animalType: 'Cows',
                                    count: 1,
                                    date: '3/25/2025',
                                    feedType: 'Winter Lick',
                                    dailyIntake: 0.50,
                                    intakeUnit: 'kg',
                                    totalFeed: 60.00,
                                    duration: 120,
                                    dailyCost: 2.80,
                                    costPerAnimal: 2.80,
                                    totalCost: 336.00
                                }
                            ];
                            
                            console.log('Feed calculations mock data prepared:', feedCalculations.length, 'records');
                            
                            // Build HTML report
                            reportHTML = `
                                <div class="report-header">
                                    <div class="report-type-header">
                                        <div class="report-type-title">Feed Calculations Report</div>
                                        <div class="report-actions">
                                            <button onclick="window.print()" class="print-button">Print Report</button>
                                            <button onclick="exportReportToCSV('feed-calculations')" class="export-button">Export to CSV</button>
                                        </div>
                                    </div>
                                    <div class="report-summary">
                                        <p>Report date range: ${formatDate(startDate)} to ${formatDate(endDate)}</p>
                                        <p>Total number of calculations: ${feedCalculations.length}</p>
                                        <p>Total feed cost: ${formatCurrency(feedCalculations.reduce((sum, calc) => sum + calc.totalCost, 0))}</p>
                                    </div>
                                </div>
                                
                                <div class="report-section">
                                    <h3>Feed Calculations</h3>
                            `;
                            
                            // Generate calculation cards
                            feedCalculations.forEach(calc => {
                                reportHTML += `
                                    <div class="calculation-card feed-calculation-card">
                                        <div class="card-header">
                                            <h4>${calc.animalType} (${calc.count} animals)</h4>
                                            <div class="calculation-date">${formatDate(calc.date)}</div>
                                        </div>
                                        <div class="card-body">
                                            <div class="feed-details">
                                                <p><strong>Feed:</strong> ${calc.feedType}</p>
                                                <p><strong>Daily intake:</strong> ${calc.dailyIntake.toFixed(2)}${calc.intakeUnit} per animal</p>
                                                <p><strong>Total feed:</strong> ${calc.totalFeed.toFixed(2)}${calc.intakeUnit} (${calc.duration} days)</p>
                                            </div>
                                            <div class="cost-details">
                                                <p><strong>Daily cost:</strong> ${formatCurrency(calc.dailyCost)}</p>
                                                <p><strong>Per animal:</strong> ${formatCurrency(calc.costPerAnimal)}/day</p>
                                                <p><strong>Total (${calc.duration} days):</strong> ${formatCurrency(calc.totalCost)}</p>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            });
                            
                            // Add summary table
                            reportHTML += `
                                <h3>Summary Table</h3>
                                <table class="report-table">
                                    <thead>
                                        <tr>
                                            <th>Animal Type</th>
                                            <th>Count</th>
                                            <th>Feed Type</th>
                                            <th>Daily Intake</th>
                                            <th>Total Feed</th>
                                            <th>Duration</th>
                                            <th>Daily Cost</th>
                                            <th>Cost per Animal</th>
                                            <th>Total Cost</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                            `;
                            
                            feedCalculations.forEach(calc => {
                                reportHTML += `
                                    <tr>
                                        <td>${calc.animalType}</td>
                                        <td>${calc.count}</td>
                                        <td>${calc.feedType}</td>
                                        <td>${calc.dailyIntake.toFixed(2)}${calc.intakeUnit}</td>
                                        <td>${calc.totalFeed.toFixed(2)}${calc.intakeUnit}</td>
                                        <td>${calc.duration} days</td>
                                        <td>${formatCurrency(calc.dailyCost)}</td>
                                        <td>${formatCurrency(calc.costPerAnimal)}/day</td>
                                        <td>${formatCurrency(calc.totalCost)}</td>
                                    </tr>
                                `;
                            });
                            
                            // Add totals row
                            const totalCost = feedCalculations.reduce((sum, calc) => sum + calc.totalCost, 0);
                            reportHTML += `
                                    <tr class="total-row">
                                        <td colspan="8" class="text-right"><strong>Total Cost:</strong></td>
                                        <td>${formatCurrency(totalCost)}</td>
                                    </tr>
                                </tbody>
                                </table>
                                
                                <div class="report-notes">
                                    <h4>Notes:</h4>
                                    <ul>
                                        <li>Feed calculations are based on standard nutritional requirements for each animal type.</li>
                                        <li>Costs are calculated using current feed prices stored in the system.</li>
                                        <li>Actual consumption may vary based on animal health, weather conditions, and other factors.</li>
                                    </ul>
                                </div>
                            </div>
                            `;
                            
                            console.log('Feed calculation HTML generated successfully (inline)');
                        } catch (error) {
                            console.error('Error generating feed calculation report:', error);
                            reportHTML = `<div class="error-message">Error generating feed calculations: ${error.message}</div>`;
                        }
                        break;
                        
                    case 'feed-inventory':
                        // For inventory report, we need to add the transactions for days remaining calculation
                        const feedTransactionsStr = await mobileStorage.getItem('feedTransactions');
                        const feedTransactions = feedTransactionsStr ? JSON.parse(feedTransactionsStr) : [];
                        
                        // Structure the data properly for the inventory table
                        const inventoryReportData = {
                            feedInventory: reportData,
                            feedTransactions: feedTransactions
                        };
                        
                        reportHTML = createFeedInventoryTable(inventoryReportData);
                        break;
                        
                    default:
                        reportResults.innerHTML = `<div class="error-message">Report type not supported yet: ${filters.reportType}</div>`;
                        return;
                }
                
                // Display the report
                reportResults.innerHTML = reportHTML;
                
                // Log after successfully rendering
                console.log(`Successfully rendered ${filters.reportType} report`);
                
            } catch (error) {
                console.error('Error generating report HTML:', error);
                reportResults.innerHTML = `<div class="error-message">Error generating report: ${error.message}</div>`;
            }
            
        } catch (error) {
            console.error('Error handling report generation:', error);
            reportResults.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
        }
    }
    
    /**
     * Format report title for display
     */
    function formatReportTitle(reportType) {
        if (!reportType) return 'Unknown';
        
        // Convert kebab-case to title case
        return reportType
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
    
    /**
     * Create table for all feed records
     */
    function createAllFeedReportTable(data) {
        try {
            if (!data || data.length === 0) {
                return `<div class="report-empty">No feed calculation data found for the selected period</div>`;
            }
            
            // Calculate totals and stats, respecting existing calculations
            let totalPurchased = 0;
            let totalUsed = 0;
            let totalPurchaseCost = 0;
            let totalUsageCost = 0;
            let totalFeed = 0;
            
            // Track units for consistency
            const unitTracking = {};
            
            // Group by feed type
            const feedTypeStats = {};
            
            // Initialize feedTypeGroups for calculations summary
            const feedTypeGroups = {};
            
            // Initialize HTML string
            let html = `
                <div class="report-header">
                    <div class="report-type-header">
                        <div class="report-type-title">All Feed Transactions</div>
                        <div class="report-actions">
                            <button onclick="window.print()" class="print-button">Print Report</button>
                            <button onclick="exportReportToCSV('all-feed')" class="export-button">Export to CSV</button>
                        </div>
                    </div>
                    <div class="report-summary">
                        <p>Total Feed Purchased: <span id="totalPurchased">Calculating...</span></p>
                        <p>Total Feed Used: <span id="totalUsed">Calculating...</span></p>
                        <p>Total Purchase Cost: <span id="totalCost">Calculating...</span></p>
                    </div>
                </div>
            `;
            
            data.forEach(record => {
                const feedType = record.feedType || 'Unknown';
                const quantity = parseFloat(record.quantity) || 0;
                const unit = record.unit || '';
                
                // Track units
                if (unit) {
                    unitTracking[unit] = (unitTracking[unit] || 0) + 1;
                }
                
                // Initialize feed type stats if not exists
                if (!feedTypeStats[feedType]) {
                    feedTypeStats[feedType] = {
                        purchased: 0,
                        used: 0,
                        purchaseCost: 0,
                        usageCost: 0,
                        records: 0,
                        unit: unit // Store the unit with the feed type
                    };
                }
                
                // Initialize feed type groups for calculations
                if (!feedTypeGroups[feedType]) {
                    feedTypeGroups[feedType] = {
                        count: 0,
                        totalAmount: 0,
                        unit: unit,
                        totalCost: 0  // Ensure this is initialized
                    };
                }
                
                feedTypeStats[feedType].records++;
                feedTypeGroups[feedType].count++;
                
                // Add to feed type groups for calculation summary
                feedTypeGroups[feedType].totalAmount += quantity;
                
                // Update total feed count
                totalFeed += quantity;
                
                if (record.type === 'purchase') {
                    totalPurchased += quantity;
                    feedTypeStats[feedType].purchased += quantity;
                    
                    // Use existing calculated cost if available
                    if (record.calculatedCost) {
                        const cost = parseFloat(record.calculatedCost);
                        totalPurchaseCost += cost;
                        feedTypeStats[feedType].purchaseCost += cost;
                        feedTypeGroups[feedType].totalCost += cost;
                    } else if (record.totalPrice) {
                        const cost = parseFloat(record.totalPrice) || 0;
                        totalPurchaseCost += cost;
                        feedTypeStats[feedType].purchaseCost += cost;
                        feedTypeGroups[feedType].totalCost += cost;
                    } else if (record.pricePerUnit && record.quantity) {
                        const cost = parseFloat(record.pricePerUnit) * quantity;
                        totalPurchaseCost += cost;
                        feedTypeStats[feedType].purchaseCost += cost;
                        feedTypeGroups[feedType].totalCost += cost;
                    }
                } else if (record.type === 'usage') {
                    totalUsed += quantity;
                    feedTypeStats[feedType].used += quantity;
                    
                    // Use existing calculated cost if available - track separately but don't add to total
                    if (record.totalCost) {
                        const cost = parseFloat(record.totalCost) || 0;
                        totalUsageCost += cost;
                        feedTypeStats[feedType].usageCost += cost;
                    } else if (record.cost) {
                        const cost = parseFloat(record.cost) || 0;
                        totalUsageCost += cost;
                        feedTypeStats[feedType].usageCost += cost;
                    }
                    
                    // Try to fetch price info from corresponding purchase if missing
                    if (!record.totalCost && !record.cost) {
                        // Look for the latest purchase of this feed type
                        const latestPurchase = data.find(r => 
                            r.type === 'purchase' && 
                            r.feedType === feedType && 
                            (r.totalPrice || r.pricePerUnit)
                        );
                        
                        if (latestPurchase) {
                            let costPerUnit = 0;
                            if (latestPurchase.pricePerUnit) {
                                costPerUnit = parseFloat(latestPurchase.pricePerUnit);
                            } else if (latestPurchase.totalPrice && latestPurchase.quantity) {
                                costPerUnit = latestPurchase.totalPrice / latestPurchase.quantity;
                            }
                            
                            if (costPerUnit > 0) {
                                const calculatedCost = costPerUnit * quantity;
                                totalUsageCost += calculatedCost;
                                feedTypeStats[feedType].usageCost += calculatedCost;
                                
                                // Update the record with calculated cost for display
                                record.calculatedCost = calculatedCost;
                            }
                        }
                    }
                }
            });
            
            // Determine the most common unit for the total
            let commonUnit = '';
            const unitCounts = {};
            
            for (const [unit, count] of Object.entries(unitTracking)) {
                unitCounts[unit] = (unitCounts[unit] || 0) + count;
            }
            
            let maxCount = 0;
            for (const [unit, count] of Object.entries(unitCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    commonUnit = unit;
                }
            }
            
            // Update summary with calculated values
            html = html.replace('<span id="totalPurchased">Calculating...</span>', 
                `${totalPurchased.toFixed(2)} ${commonUnit}`);
            html = html.replace('<span id="totalUsed">Calculating...</span>', 
                `${totalUsed.toFixed(2)} ${commonUnit}`);
            html = html.replace('<span id="totalCost">Calculating...</span>', 
                formatCurrency(totalPurchaseCost));
            
            // Generate table of transactions
            html += `
                <div class="report-section">
                    <h3>All Feed Transactions</h3>
                    <table class="report-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Type</th>
                                <th>Feed Type</th>
                                <th>Quantity</th>
                                <th>Cost</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort data by date (newest first)
            const sortedData = [...data].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Group transactions by month for better visual separation
            let currentMonth = '';
            
            for (const record of sortedData) {
                const date = new Date(record.date);
                const month = date.toLocaleString('default', { month: 'long', year: 'numeric' });
                
                // Add month separator
                if (month !== currentMonth) {
                    html += `
                        <tr class="month-separator">
                            <td colspan="6"><strong>${month}</strong></td>
                        </tr>
                    `;
                    currentMonth = month;
                }
                
                const formattedDate = formatDate(record.date);
                const transactionType = record.type === 'purchase' ? 'Purchase' : 'Usage';
                const feedType = record.feedType || 'Unknown';
                const quantity = `${parseFloat(record.quantity).toFixed(2)} ${record.unit || commonUnit}`;
                
                // Determine cost value
                let cost = '-';
                let costClass = '';
                
                if (record.type === 'purchase') {
                    if (record.calculatedCost) {
                        cost = formatCurrency(record.calculatedCost);
                        costClass = 'calculated-cost';
                    } else if (record.totalPrice) {
                        cost = formatCurrency(record.totalPrice);
                    } else if (record.pricePerUnit) {
                        cost = `${formatCurrency(record.pricePerUnit)} per ${record.unit || commonUnit}`;
                    }
                } else {
                    // For usage transactions
                    if (record.calculatedCost) {
                        cost = formatCurrency(record.calculatedCost);
                        costClass = 'calculated-cost';
                    } else if (record.totalCost) {
                        cost = formatCurrency(record.totalCost);
                    } else {
                        cost = '-'; // No cost for usage if not specified
                    }
                }
                
                const notes = record.notes || '-';
                
                html += `
                    <tr class="${record.type}-row">
                        <td>${formattedDate}</td>
                        <td>${transactionType}</td>
                        <td>${feedType}</td>
                        <td>${quantity}</td>
                        <td class="${costClass}">${cost}</td>
                        <td>${notes}</td>
                    </tr>
                `;
            }
            
            html += `
                        </tbody>
                        <tfoot>
                            <tr>
                                <td colspan="3" class="total-label">Total:</td>
                                <td>${totalFeed.toFixed(2)} ${commonUnit}</td>
                                <td>${formatCurrency(totalPurchaseCost)}</td>
                                <td></td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `;
            
            // Add summary by feed type
            if (Object.keys(feedTypeGroups).length > 0) {
                html += `
                    <h4>Summary by Feed Type</h4>
                    <table class="report-table summary-table">
                        <thead>
                            <tr>
                                <th>Feed Type</th>
                                <th>Number of Transactions</th>
                                <th>Purchased</th>
                                <th>Used</th>
                                <th>Net Change</th>
                                <th>Purchase Cost</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (const [feedType, data] of Object.entries(feedTypeGroups)) {
                    // Get the actual stats from feedTypeStats which tracks purchased vs used separately
                    const stats = feedTypeStats[feedType];
                    const purchased = stats.purchased || 0;
                    const used = stats.used || 0;
                    const netChange = purchased - used;
                    const netChangeClass = netChange >= 0 ? 'positive-change' : 'negative-change';
                    
                    html += `
                        <tr>
                            <td>${feedType}</td>
                            <td>${data.count}</td>
                            <td>${purchased.toFixed(2)} ${data.unit || commonUnit}</td>
                            <td>${used.toFixed(2)} ${data.unit || commonUnit}</td>
                            <td class="${netChangeClass}">${netChange.toFixed(2)} ${data.unit || commonUnit}</td>
                            <td>${formatCurrency(stats.purchaseCost || 0)}</td>
                        </tr>
                    `;
                }
                
                html += `
                        </tbody>
                    </table>
                `;
            }
            
            // Add notes and methodology explanation
            html += `
                <div class="report-notes">
                    <h4>Notes:</h4>
                    <ul>
                        <li>Feed calculations are based on animal weight, category, and standard nutritional requirements.</li>
                        <li>Estimated costs are calculated using the most recent purchase price for each feed type.</li>
                        <li>Actual feed usage may vary based on animal health, weather conditions, and other factors.</li>
                        <li>Costs shown in <span class="calculated-cost">this style</span> are calculated based on the most recent purchase price.</li>
                    </ul>
                </div>
            `;
            
            return html;
        } catch (calcError) {
            console.error('Error in feed calculations handling:', calcError);
            return `<div class="error-message">Error processing feed calculations: ${calcError.message}</div>`;
        }
    }
    
    /**
     * Create table for feed purchase
     */
    function createFeedPurchaseTable(data) {
        if (!data || data.length === 0) {
            return `<div class="report-empty">No feed purchase data found for the selected period</div>`;
        }

        // Calculate totals for summary
        let totalQuantity = 0;
        let totalCost = 0;
        let avgPrice = 0;
        const supplierStats = {};
        const feedTypeStats = {};
        const unitTracking = {};
        
        // Sort data by date (newest first)
        data.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Get currency
        const selectedCurrency = mobileStorage.getItemSync('selectedCurrency') || 'ZAR';
        const worldCurrencies = [
            { code: 'GBP', name: 'British Pound', display: 'Pound', symbol: '\u00A3' },
            { code: 'EUR', name: 'Euro', display: 'Euro', symbol: '\u20AC' },
            { code: 'USD', name: 'US Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'AUD', name: 'Australian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'NZD', name: 'New Zealand Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'CAD', name: 'Canadian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'ZAR', name: 'South African Rand', display: 'Rand', symbol: 'R' }
        ];
        
        const currency = worldCurrencies.find(c => c.code === selectedCurrency) || { symbol: 'R' };
        
        data.forEach(record => {
            const quantity = parseFloat(record.quantity) || 0;
            const unit = record.unit || 'kg';
            let pricePerUnit = 0;
            let recordTotalPrice = 0;
            
            // Track units for consistency
            unitTracking[unit] = (unitTracking[unit] || 0) + 1;
            
            // Calculate total price in a consistent way
            if (record.totalPrice) {
                recordTotalPrice = parseFloat(record.totalPrice);
            } else if (record.pricePerUnit && quantity) {
                pricePerUnit = parseFloat(record.pricePerUnit);
                recordTotalPrice = pricePerUnit * quantity;
            }
            
            // If we didn't get pricePerUnit directly, calculate it
            if (pricePerUnit === 0 && recordTotalPrice > 0 && quantity > 0) {
                pricePerUnit = recordTotalPrice / quantity;
            }
            
            totalQuantity += quantity;
            totalCost += recordTotalPrice;
            
            // Supplier statistics
            const supplier = record.supplier || 'Unknown';
            if (!supplierStats[supplier]) {
                supplierStats[supplier] = {
                    count: 0,
                    totalQuantity: 0,
                    totalCost: 0,
                    unit: unit
                };
            }
            
            supplierStats[supplier].count++;
            supplierStats[supplier].totalQuantity += quantity;
            supplierStats[supplier].totalCost += recordTotalPrice;
            
            // Feed type statistics
            const feedType = record.feedType || 'Unknown';
            if (!feedTypeStats[feedType]) {
                feedTypeStats[feedType] = {
                    count: 0,
                    totalQuantity: 0,
                    totalCost: 0,
                    priceHistory: [],
                    unit: unit
                };
            }
            
            feedTypeStats[feedType].count++;
            feedTypeStats[feedType].totalQuantity += quantity;
            feedTypeStats[feedType].totalCost += recordTotalPrice;
            
            if (pricePerUnit > 0) {
                feedTypeStats[feedType].priceHistory.push({
                    date: record.date,
                    price: pricePerUnit
                });
            }
        });
        
        // Calculate average price per unit
        avgPrice = totalQuantity > 0 ? totalCost / totalQuantity : 0;
        
        // Determine the most common unit for display
        let primaryUnit = '';
        let maxUnitCount = 0;
        
        for (const [unit, count] of Object.entries(unitTracking)) {
            if (count > maxUnitCount) {
                maxUnitCount = count;
                primaryUnit = unit;
            }
        }

        // Build report
        let html = `
            <div class="report-header">
                <div class="report-type-header">
                    <div class="report-type-title">Feed Purchase Report</div>
                    <div class="report-actions">
                        <button onclick="window.print()" class="print-button">Print Report</button>
                        <button onclick="exportReportToCSV('feed-purchase')" class="export-button">Export to CSV</button>
                    </div>
                </div>
                <div class="report-summary">
                    <p>Total Quantity: ${totalQuantity.toFixed(2)} ${primaryUnit}</p>
                    <p>Total Cost: ${formatCurrency(totalCost)}</p>
                    <p>Average Price: ${formatCurrency(avgPrice)} per ${primaryUnit}</p>
                    <p>Records: ${data.length}</p>
                </div>
            </div>

            <div class="report-section">
                <h3>Purchase Records</h3>
                <table class="report-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Feed Type</th>
                            <th>Quantity</th>
                            <th>Price Per Unit</th>
                            <th>Total Price</th>
                            <th>Supplier</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
    `;

    // Group transactions by month for better visual separation
    let currentMonth = '';

    data.forEach(record => {
        const date = new Date(record.date);
        const month = date.toLocaleString('default', { month: 'long', year: 'numeric' });
        
        if (month !== currentMonth) {
            html += `
                <tr class="month-separator">
                    <td colspan="7"><strong>${month}</strong></td>
                </tr>
            `;
            currentMonth = month;
        }
        
        const formattedDate = formatDate(record.date);
        const feedType = record.feedType || 'Unknown';
        const quantity = `${parseFloat(record.quantity).toFixed(2)} ${record.unit || primaryUnit}`;
        const supplier = record.supplier || 'Unknown';
        
        // Format prices consistently
        let pricePerUnit = '-';
        if (record.pricePerUnit) {
            pricePerUnit = `${formatCurrency(record.pricePerUnit)}/${record.unit || primaryUnit}`;
        } else if (record.totalPrice && parseFloat(record.quantity) > 0) {
            const calculatedPricePerUnit = parseFloat(record.totalPrice) / parseFloat(record.quantity);
            pricePerUnit = `${formatCurrency(calculatedPricePerUnit)}/${record.unit || primaryUnit}`;
        }
        
        const totalPrice = record.totalPrice ? formatCurrency(record.totalPrice) : '-';
        const notes = record.notes || '-';
        
        html += `
            <tr class="purchase-row">
                <td>${formattedDate}</td>
                <td>${feedType}</td>
                <td>${quantity}</td>
                <td>${pricePerUnit}</td>
                <td>${totalPrice}</td>
                <td>${supplier}</td>
                <td>${notes}</td>
            </tr>
        `;
    });

    html += `
                </tbody>
                <tfoot>
                    <tr>
                        <td colspan="2" class="total-label">Totals:</td>
                        <td>${totalQuantity.toFixed(2)} ${primaryUnit}</td>
                        <td>${formatCurrency(avgPrice)}/${primaryUnit} (avg)</td>
                        <td>${formatCurrency(totalCost)}</td>
                        <td colspan="2"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    `;
        
        // Add summary by feed type
        if (Object.keys(feedTypeStats).length > 0) {
            html += `
                <h4>Summary by Feed Type</h4>
                <table class="report-table summary-table">
                    <thead>
                        <tr>
                            <th>Feed Type</th>
                            <th>Transactions</th>
                            <th>Total Quantity</th>
                            <th>Total Cost</th>
                            <th>Average Price</th>
                            <th>Latest Price</th>
                            <th>Price Trend</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const [feedType, stats] of Object.entries(feedTypeStats)) {
                // Calculate average price
                const avgFeedPrice = stats.totalQuantity > 0 ? stats.totalCost / stats.totalQuantity : 0;
                const unit = stats.unit || primaryUnit;
                
                // Get latest price if available
                let latestPrice = '-';
                let priceTrend = '-';
                
                if (stats.priceHistory.length > 0) {
                    // Sort by date, newest first
                    stats.priceHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
                    latestPrice = formatCurrency(stats.priceHistory[0].price) + '/' + unit;
                    
                    // Calculate trend if we have at least 2 prices
                    if (stats.priceHistory.length >= 2) {
                        const oldest = stats.priceHistory[stats.priceHistory.length - 1].price;
                        const newest = stats.priceHistory[0].price;
                        
                        if (newest > oldest) {
                            priceTrend = `⬆️ +${((newest - oldest) / oldest * 100).toFixed(1)}%`;
                        } else if (newest < oldest) {
                            priceTrend = `⬇️ ${((newest - oldest) / oldest * 100).toFixed(1)}%`;
                        } else {
                            priceTrend = '⟷ No change';
                        }
                    }
                }
                
                html += `
                    <tr>
                        <td>${feedType}</td>
                        <td>${stats.count}</td>
                        <td>${stats.totalQuantity.toFixed(2)} ${unit}</td>
                        <td>${formatCurrency(stats.totalCost)}</td>
                        <td>${formatCurrency(avgFeedPrice)}/${unit}</td>
                        <td>${latestPrice}</td>
                        <td>${priceTrend}</td>
                    </tr>
                `;
            }
            
            html += `
                    </tbody>
                </table>
            `;
        }
        
        // Add supplier summary
        if (Object.keys(supplierStats).length > 0) {
            html += `
                <h4>Summary by Supplier</h4>
                <table class="report-table summary-table">
                    <thead>
                        <tr>
                            <th>Supplier</th>
                            <th>Transactions</th>
                            <th>Total Quantity</th>
                            <th>Total Cost</th>
                            <th>Average Price</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const [supplier, stats] of Object.entries(supplierStats)) {
                const avgSupplierPrice = stats.totalQuantity > 0 ? stats.totalCost / stats.totalQuantity : 0;
                const unit = stats.unit || primaryUnit;
                
                html += `
                    <tr>
                        <td>${supplier}</td>
                        <td>${stats.count}</td>
                        <td>${stats.totalQuantity.toFixed(2)} ${unit}</td>
                        <td>${formatCurrency(stats.totalCost)}</td>
                        <td>${formatCurrency(avgSupplierPrice)}/${unit}</td>
                    </tr>
                `;
            }
            
            html += `
                    </tbody>
                </table>
            `;
        }
        
        // Add report notes
        html += `
            <div class="report-notes">
                <h4>Notes:</h4>
                <ul>
                    <li>Average prices are calculated as (total cost ÷ total quantity).</li>
                    <li>Where price per unit is not directly specified, it is calculated from the total price and quantity.</li>
                    <li>Price trends indicate the percentage change from the oldest to newest transaction.</li>
                    <li>Transactions are grouped by month for easier viewing.</li>
                </ul>
                </div>
            `;
        
        return html;
    }
    
    /**
     * Create table for feed usage
     */
    function createFeedUsageTable(data) {
        if (!data || !data.feedTransactions || data.feedTransactions.length === 0) {
            return `<div class="report-empty">No feed usage data found for the selected period</div>`;
        }

        const transactions = data.feedTransactions;
        if (transactions.length === 0) {
            return `<div class="report-empty">No feed usage data found for the selected period</div>`;
        }

        // Sort transactions by date, most recent first
        transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

        // Get currency
        const selectedCurrency = mobileStorage.getItemSync('selectedCurrency') || 'ZAR';
        const worldCurrencies = [
            { code: 'GBP', name: 'British Pound', display: 'Pound', symbol: '\u00A3' },
            { code: 'EUR', name: 'Euro', display: 'Euro', symbol: '\u20AC' },
            { code: 'USD', name: 'US Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'AUD', name: 'Australian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'NZD', name: 'New Zealand Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'CAD', name: 'Canadian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'ZAR', name: 'South African Rand', display: 'Rand', symbol: 'R' }
        ];
        
        const currency = worldCurrencies.find(c => c.code === selectedCurrency) || { symbol: 'R' };

        // Calculate totals and statistics
        let totalUsage = 0;
        let totalCost = 0;
        let totalUsageKg = 0;
        const animalGroupStats = new Map();
        const feedTypeStats = new Map();
        const monthlyStats = new Map();
        const unitTracking = {};
        
        transactions.forEach(t => {
            // Track units for consistency
            unitTracking[t.unit] = (unitTracking[t.unit] || 0) + 1;
            
            // Add to total usage (in original units and kg if available)
            totalUsage += t.quantity || 0;
            totalUsageKg += t.weightInKg || 0;
            
            // Get cost value (use totalCost, cost, or calculated cost)
            const costValue = t.totalCost || t.cost || 0;
            totalCost += costValue;
            
            // Group by animal category
            const animalCategory = t.animalCategory || t.animalGroup || 'Unknown';
            if (!animalGroupStats.has(animalCategory)) {
                animalGroupStats.set(animalCategory, {
                    totalUsage: 0,
                    totalUsageKg: 0,
                    totalCost: 0,
                    recordCount: 0,
                    feedTypes: new Map()
                });
            }
            const animalStats = animalGroupStats.get(animalCategory);
            animalStats.totalUsage += t.quantity || 0;
            animalStats.totalUsageKg += t.weightInKg || 0;
            animalStats.totalCost += costValue;
            animalStats.recordCount++;
            
            // Track by feed type within animal group
            if (!animalStats.feedTypes.has(t.feedType)) {
                animalStats.feedTypes.set(t.feedType, {
                    totalUsage: 0,
                    totalUsageKg: 0,
                    totalCost: 0,
                    records: 0
                });
            }
            const feedTypeInAnimal = animalStats.feedTypes.get(t.feedType);
            feedTypeInAnimal.totalUsage += t.quantity || 0;
            feedTypeInAnimal.totalUsageKg += t.weightInKg || 0;
            feedTypeInAnimal.totalCost += costValue;
            feedTypeInAnimal.records++;
            
            // Group by feed type
            if (!feedTypeStats.has(t.feedType)) {
                feedTypeStats.set(t.feedType, {
                    totalUsage: 0,
                    totalUsageKg: 0,
                    totalCost: 0,
                    recordCount: 0,
                    unit: t.unit
                });
            }
            const feedStats = feedTypeStats.get(t.feedType);
            feedStats.totalUsage += t.quantity || 0;
            feedStats.totalUsageKg += t.weightInKg || 0;
            feedStats.totalCost += costValue;
            feedStats.recordCount++;
            
            // Group by month
            const month = new Date(t.date).toLocaleString('default', { month: 'long', year: 'numeric' });
            if (!monthlyStats.has(month)) {
                monthlyStats.set(month, {
                    totalUsage: 0,
                    totalUsageKg: 0,
                    totalCost: 0,
                    recordCount: 0
                });
            }
            const monthStat = monthlyStats.get(month);
            monthStat.totalUsage += t.quantity || 0;
            monthStat.totalUsageKg += t.weightInKg || 0;
            monthStat.totalCost += costValue;
            monthStat.recordCount++;
        });

        // Determine the primary unit (most common)
        const primaryUnit = Object.entries(unitTracking).sort((a, b) => b[1] - a[1])[0]?.[0] || 'kg';

        // Create table
        let table = `
            <div class="report-header">
                <div class="report-type-header">
                    <div class="report-type-title">Feed Usage Report</div>
                    <div class="report-actions">
                        <button onclick="window.print()" class="print-button">Print Report</button>
                        <button onclick="exportReportToCSV('feed-usage')" class="export-button">Export to CSV</button>
                    </div>
                </div>
                <div class="report-summary">
                    <p>Total Feed Used: ${totalUsage.toFixed(2)} ${primaryUnit}${totalUsageKg > 0 ? ` (${totalUsageKg.toFixed(2)} kg)` : ''}</p>
                    <p>Total Cost: ${currency.symbol}${totalCost.toFixed(2)}</p>
                    <p>Average Cost per kg: ${currency.symbol}${(totalUsageKg > 0 ? totalCost / totalUsageKg : 0).toFixed(2)}</p>
                    <p>Usage Records: ${transactions.length}</p>
                </div>
            </div>

            <div class="report-section">
                <h3>Feed Usage Records</h3>
                <table class="report-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Feed Type</th>
                            <th>Quantity</th>
                            <th>Weight (kg)</th>
                            <th>Animal Group</th>
                            <th>Cost</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
    `;

        // Group transactions by month for better visual separation
        let currentMonth = '';
        
        transactions.forEach(t => {
            const recordDate = new Date(t.date);
            const month = recordDate.toLocaleString('default', { month: 'long', year: 'numeric' });
            
            // Add month separator if changed
            if (month !== currentMonth) {
                currentMonth = month;
                table += `
                    <tr class="month-separator">
                        <td colspan="7"><strong>${month}</strong></td>
                    </tr>
                `;
            }
            
            const formattedDate = formatDate(t.date);
            const feedType = t.feedType || 'Unknown';
            const quantity = t.quantity ? `${t.quantity} ${t.unit || primaryUnit}` : '-';
            const weight = t.weightInKg ? `${t.weightInKg.toFixed(2)} kg` : '-';
            const animalGroup = t.animalCategory || t.animalGroup || '-';
            const costValue = t.totalCost || t.cost || 0;
            const cost = costValue ? `${currency.symbol}${costValue.toFixed(2)}` : '-';
            const notes = t.notes || '-';
            
            // Add a marker for calculated costs
            const costClass = t.priceSource === 'calculated' ? 'calculated-cost' : '';
            
            table += `
                <tr>
                    <td>${formattedDate}</td>
                    <td>${feedType}</td>
                    <td>${quantity}</td>
                    <td>${weight}</td>
                    <td>${animalGroup}</td>
                    <td class="${costClass}">${cost}</td>
                    <td>${notes}</td>
                </tr>
            `;
        });
        
        table += `
                </tbody>
            </table>
        </div>
    `;

        // Add summary by animal category
        if (animalGroupStats.size > 0) {
            table += `
                <div class="report-section">
                    <h3>Usage by Animal Group</h3>
                    <table class="report-table summary-table">
                        <thead>
                            <tr>
                                <th>Animal Group</th>
                                <th>Records</th>
                                <th>Usage (${primaryUnit})</th>
                                <th>Weight (kg)</th>
                                <th>Cost</th>
                                <th>% of Total Cost</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Convert Map to array and sort by usage (highest first)
            const animalArray = Array.from(animalGroupStats.entries()).sort((a, b) => b[1].totalCost - a[1].totalCost);
            
            animalArray.forEach(([animalGroup, stats]) => {
                const percentOfTotal = totalCost > 0 ? (stats.totalCost / totalCost * 100) : 0;
                
                table += `
                    <tr>
                        <td>${animalGroup}</td>
                        <td>${stats.recordCount}</td>
                        <td>${stats.totalUsage.toFixed(2)} ${primaryUnit}</td>
                        <td>${stats.totalUsageKg.toFixed(2)} kg</td>
                        <td>${currency.symbol}${stats.totalCost.toFixed(2)}</td>
                        <td>${percentOfTotal.toFixed(1)}%</td>
                    </tr>
                `;
            });
            
            table += `
                    </tbody>
                </table>
            </div>
            `;
        }

        // Add summary by feed type
        if (feedTypeStats.size > 0) {
            table += `
                <div class="report-section">
                    <h3>Usage by Feed Type</h3>
                    <table class="report-table summary-table">
                        <thead>
                            <tr>
                                <th>Feed Type</th>
                                <th>Records</th>
                                <th>Usage</th>
                                <th>Cost</th>
                                <th>Cost per kg</th>
                                <th>% of Total Cost</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Convert Map to array and sort by usage (highest first)
            const feedTypeArray = Array.from(feedTypeStats.entries()).sort((a, b) => b[1].totalCost - a[1].totalCost);
            
            feedTypeArray.forEach(([feedType, stats]) => {
                const avgCostPerKg = stats.totalUsageKg > 0 ? stats.totalCost / stats.totalUsageKg : 0;
                const percentOfTotalCost = totalCost > 0 ? (stats.totalCost / totalCost * 100) : 0;
                
                table += `
                    <tr>
                        <td>${feedType}</td>
                        <td>${stats.recordCount}</td>
                        <td>${stats.totalUsage.toFixed(2)} ${stats.unit}</td>
                        <td>${currency.symbol}${stats.totalCost.toFixed(2)}</td>
                        <td>${currency.symbol}${avgCostPerKg.toFixed(2)}</td>
                        <td>${percentOfTotalCost.toFixed(1)}%</td>
                    </tr>
                `;
            });

            table += `
                    </tbody>
                </table>
            </div>
            `;
        }

        // Add monthly usage trends
        table += `
            <div class="report-section">
                <h3>Monthly Usage Trends</h3>
                <table class="report-table summary-table">
                    <thead>
                        <tr>
                            <th>Month</th>
                            <th>Usage (kg)</th>
                            <th>Total Cost</th>
                            <th>Avg. Cost/kg</th>
                            <th>Records</th>
                        </tr>
                    </thead>
                    <tbody>
    `;

        // Convert Map to array and sort by date (month)
        const monthArray = Array.from(monthlyStats.entries());
        // Create a map function to convert month names to numbers for sorting
        const monthToNum = {
            'January': 0, 'February': 1, 'March': 2, 'April': 3, 'May': 4, 'June': 5,
            'July': 6, 'August': 7, 'September': 8, 'October': 9, 'November': 10, 'December': 11
        };
        
        // Sort by year and month
        monthArray.sort((a, b) => {
            const aMonthYear = a[0].split(' ');
            const bMonthYear = b[0].split(' ');
            const aYear = parseInt(aMonthYear[1]);
            const bYear = parseInt(bMonthYear[1]);
            
            if (aYear !== bYear) return bYear - aYear; // Most recent year first
            return monthToNum[bMonthYear[0]] - monthToNum[aMonthYear[0]]; // Most recent month first
        });
        
        monthArray.forEach(([month, stats]) => {
            const avgCostPerKg = stats.totalUsageKg > 0 ? stats.totalCost / stats.totalUsageKg : 0;
            
            table += `
                <tr>
                    <td>${month}</td>
                    <td>${stats.totalUsageKg.toFixed(2)} kg</td>
                    <td>${currency.symbol}${stats.totalCost.toFixed(2)}</td>
                    <td>${currency.symbol}${avgCostPerKg.toFixed(2)}</td>
                    <td>${stats.recordCount}</td>
                </tr>
            `;
        });

        table += `
                    </tbody>
                </table>
            </div>
        `;

        // Add report notes
        table += `
            <div class="report-notes">
                <h3>Notes</h3>
                <ul>
                    <li>This report shows all feed usage records for the selected period.</li>
                    <li>Weight in kg is derived from the weight equivalent for non-weight units like bags or bales.</li>
                    <li>Cost calculations are based on the unit price of feed at time of usage.</li>
                    <li>Costs shown in <span class="calculated-cost">this style</span> are calculated based on the most recent purchase price.</li>
                    <li>Percentage calculations help identify which animal groups or feed types represent the largest portion of feed expenses.</li>
                </ul>
            </div>
        `;

        return table;
    }
    
    /**
     * Create table for feed inventory
     */
    function createFeedInventoryTable(data) {
        if (!data || !data.feedInventory || data.feedInventory.length === 0) {
            return `
                <div class="report-empty">
                    <p>No feed inventory data available for the selected period.</p>
                    <p>Add feed inventory items to view this report.</p>
                </div>
            `;
        }

        // Get the inventory data
        const inventoryData = data.feedInventory;
        if (inventoryData.length === 0) {
            return `
                <div class="report-empty">
                    <p>No feed inventory data available for the selected period.</p>
                    <p>Add feed inventory items to view this report.</p>
                </div>
            `;
        }

        // Get currency
        const selectedCurrency = mobileStorage.getItemSync('selectedCurrency') || 'ZAR';
        const worldCurrencies = [
            { code: 'GBP', name: 'British Pound', display: 'Pound', symbol: '\u00A3' },
            { code: 'EUR', name: 'Euro', display: 'Euro', symbol: '\u20AC' },
            { code: 'USD', name: 'US Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'AUD', name: 'Australian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'NZD', name: 'New Zealand Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'CAD', name: 'Canadian Dollar', display: 'Dollar', symbol: '\u0024' },
            { code: 'ZAR', name: 'South African Rand', display: 'Rand', symbol: 'R' }
        ];
        
        const currency = worldCurrencies.find(c => c.code === selectedCurrency) || { symbol: 'R' };

        // Calculate total inventory value and track units
        let totalValue = 0;
        let totalQuantity = 0;
        let totalQuantityKg = 0;
        const unitTracking = {};
        const categoryTotals = {};

        // Process all inventory entries - handle both formats
        // If it's an array of objects (from updated loadFeedInventoryData)
        const inventoryItems = Array.isArray(inventoryData[0]) && typeof inventoryData[0][1] === 'object' 
            ? inventoryData.map(([feedType, data]) => ({ feedType, ...data }))
            : inventoryData;
        
        // Identify low stock items
        const lowStockItems = [];
        
        // Calculate total value of inventory and summarize by units
        inventoryItems.forEach(item => {
            const unit = item.unit || 'kg';
            const quantity = parseFloat(item.quantity) || 0;
            const price = parseFloat(item.price) || 0;
            let weightInKg = 0;
            
            // Track unit for consistency
            unitTracking[unit] = (unitTracking[unit] || 0) + 1;
            
            // Calculate weight equivalent in kg
            if (unit === 'kg') {
                weightInKg = quantity;
            } else if (unit === 'lb') {
                weightInKg = quantity * 0.45359237; // Convert pounds to kg
            } else if (item.weightPerKg) {
                // If we have weight per unit data (for bags, bales)
                weightInKg = quantity * item.weightPerKg;
            } else if (['bags', 'bales'].includes(unit)) {
                // For bags and bales without specific weight data
                // Try to find weight equivalent from recent transactions
                try {
                    const feedTransactions = data.feedTransactions || [];
                    const relevantTransactions = feedTransactions.filter(t => 
                        t.feedType === item.feedType && t.weightInKg && t.quantity);
                    
                    if (relevantTransactions.length > 0) {
                        // Calculate average weight per unit from transactions
                        const avgWeightPerUnit = relevantTransactions.reduce((sum, t) => 
                            sum + (t.weightInKg / t.quantity), 0) / relevantTransactions.length;
                        
                        weightInKg = quantity * avgWeightPerUnit;
                    } else {
                        // No weight data available - show a warning
                        console.warn(`No weight data available for ${item.feedType}. Using estimated weight.`);
                        // Use a typical weight based on feed type if known, or a conservative estimate
                        const estimatedWeight = getEstimatedWeight(item.feedType);
                        weightInKg = quantity * estimatedWeight;
                    }
                } catch (error) {
                    console.error('Error calculating weight equivalent:', error);
                    // Use a conservative estimate
                    const estimatedWeight = getEstimatedWeight(item.feedType);
                    weightInKg = quantity * estimatedWeight;
                }
            }
            
            // Add to totals
            totalQuantity += quantity;
            totalQuantityKg += weightInKg;
            totalValue += quantity * price;
            
            // Store the weight in kg for later use
            item.weightInKg = weightInKg;
            
            // Categorize by feed type
            const category = getFeedCategory(item.feedType) || 'Other';
            if (!categoryTotals[category]) {
                categoryTotals[category] = 0;
            }
            categoryTotals[category] += quantity * price;
            
            // Check for low stock
            const threshold = parseFloat(item.threshold) || 0;
            if (threshold > 0 && quantity <= threshold) {
                lowStockItems.push({
                    ...item,
                    daysRemaining: estimateDaysRemaining(item, data)
                });
            }
        });

        // Sort low stock items by criticality
        lowStockItems.sort((a, b) => {
            if (a.daysRemaining === b.daysRemaining) {
                return 0;
            }
            if (a.daysRemaining === null) {
                return 1;
            }
            if (b.daysRemaining === null) {
                return -1;
            }
            return a.daysRemaining - b.daysRemaining;
        });

        // Determine primary unit (most commonly used)
        const primaryUnit = Object.entries(unitTracking).sort((a, b) => b[1] - a[1])[0]?.[0] || 'kg';

        // Start building the table
        let html = `
        <div class="report">
            <div class="report-header">
                <h3>Feed Inventory Report</h3>
                <div class="report-actions">
                    <button onclick="printReport()" class="btn-print"><i class="fas fa-print"></i> Print</button>
                    <button onclick="exportReportToCSV('feed-inventory')" class="btn-export"><i class="fas fa-file-export"></i> Export to CSV</button>
                </div>
            </div>

            <div class="inventory-summary">
                <h4>Inventory Summary</h4>
                <div class="summary-grid">
                    <div class="summary-item">
                        <div class="label">Total Inventory Value</div>
                        <div class="value">${currency.symbol}${totalValue.toFixed(2)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="label">Total Quantity</div>
                        <div class="value">${totalQuantity.toFixed(2)} ${primaryUnit}</div>
                    </div>
                    <div class="summary-item">
                        <div class="label">Total Weight</div>
                        <div class="value">${totalQuantityKg.toFixed(2)} kg</div>
                    </div>
                    <div class="summary-item">
                        <div class="label">Inventory Items</div>
                        <div class="value">${inventoryItems.length}</div>
                    </div>
                </div>
            </div>

            <h4>Current Feed Inventory</h4>
            <div class="table-responsive">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Feed Type</th>
                            <th>Current Stock</th>
                            <th>Weight (kg)</th>
                            <th>Unit Price</th>
                            <th>Value</th>
                            <th>Threshold</th>
                            <th>Status</th>
                            <th>Supplier</th>
                            <th>Last Updated</th>
                        </tr>
                    </thead>
                    <tbody>`;

        // Sort inventory by quantity (highest first)
        const sortedInventory = [...inventoryItems].sort((a, b) => {
            // Sort by weight in kg if available, otherwise by quantity
            return (b.weightInKg || parseFloat(b.quantity) || 0) - (a.weightInKg || parseFloat(a.quantity) || 0);
        });

        // Add inventory rows
        for (const item of sortedInventory) {
            const feedType = item.feedType;
            const quantity = parseFloat(item.quantity) || 0;
            const price = parseFloat(item.price) || 0;
            const threshold = parseFloat(item.threshold) || 0;
            const unit = item.unit || 'kg';
            const supplier = item.supplier || 'Not specified';
            const value = quantity * price;
            const weightInKg = item.weightInKg || 0;

            // Calculate status
            let status = 'Good';
            let statusClass = 'positive-change';
            let statusIndicator = 'status-good';

            if (threshold) {
                if (quantity <= threshold * 0.5) {
                    status = 'Critical';
                    statusClass = 'negative-change';
                    statusIndicator = 'status-critical';
                } else if (quantity <= threshold) {
                    status = 'Low';
                    statusClass = 'calculated-cost'; // Use orange for warning
                    statusIndicator = 'status-low';
                }
            }

            const supplierOrGroup = supplier || '-';
            const lastUpdated = item.lastUpdated ? formatDate(item.lastUpdated) : '-';

            html += `
                <tr>
                    <td>${feedType}</td>
                    <td>${quantity.toFixed(2)} ${unit}</td>
                    <td>${weightInKg.toFixed(2)} kg</td>
                    <td>${currency.symbol}${price.toFixed(2)}</td>
                    <td>${currency.symbol}${value.toFixed(2)}</td>
                    <td>${threshold ? threshold + ' ' + unit : '-'}</td>
                    <td class="${statusClass}"><span class="status-indicator ${statusIndicator}"></span>${status}</td>
                    <td>${supplierOrGroup}</td>
                    <td>${lastUpdated}</td>
                </tr>
            `;
        }

        html += `
                </tbody>
            </table>
        </div>`;

        // Add low stock alerts if there are any
        if (lowStockItems.length > 0) {
            html += `
            <div class="low-stock-alerts">
                <h4>Low Stock Alerts (${lowStockItems.length})</h4>
                <div class="table-responsive">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Feed Type</th>
                                <th>Current Stock</th>
                                <th>Threshold</th>
                                <th>Status</th>
                                <th>Est. Days Remaining</th>
                            </tr>
                        </thead>
                        <tbody>`;

            lowStockItems.forEach(item => {
                const feedType = item.feedType;
                const quantity = parseFloat(item.quantity) || 0;
                const unit = item.unit || 'kg';
                const threshold = parseFloat(item.threshold) || 0;
                
                // Status calculation
                let status = 'Low';
                let statusClass = 'calculated-cost';
                let statusIndicator = 'status-low';
                
                if (quantity <= threshold * 0.5) {
                    status = 'Critical';
                    statusClass = 'negative-change';
                    statusIndicator = 'status-critical';
                }
                
                // Days remaining calculation
                let daysRemainingDisplay = '-';
                let daysClass = '';
                
                if (item.daysRemaining !== null) {
                    daysRemainingDisplay = Math.round(item.daysRemaining) + ' days';
                    
                    if (item.daysRemaining <= 7) {
                        daysClass = 'days-critical';
                    } else if (item.daysRemaining <= 14) {
                        daysClass = 'days-warning';
                    } else {
                        daysClass = 'days-good';
                    }
                }
                
                html += `
                    <tr>
                        <td>${feedType}</td>
                        <td>${quantity.toFixed(2)} ${unit}</td>
                        <td>${threshold.toFixed(2)} ${unit}</td>
                        <td class="${statusClass}"><span class="status-indicator ${statusIndicator}"></span>${status}</td>
                        <td class="${daysClass}">${daysRemainingDisplay}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            </div>`;
        }

        // Add inventory value by category
        html += `
            <div class="report-section">
                <h4>Inventory Value Summary</h4>
                <div class="table-responsive">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Feed Category</th>
                                <th>Total Value</th>
                                <th>% of Inventory</th>
                            </tr>
                        </thead>
                        <tbody>`;

        Object.keys(categoryTotals).sort().forEach(category => {
            const categoryValue = categoryTotals[category];
            const percentage = (categoryValue / totalValue * 100).toFixed(1);
            
            html += `
                <tr>
                    <td>${category}</td>
                    <td>${currency.symbol}${categoryValue.toFixed(2)}</td>
                    <td>${percentage}%</td>
                </tr>
            `;
        });

        html += `
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="report-notes">
                <p><strong>Note:</strong> Inventory values are calculated based on the most recent purchase price for each feed type. 
                Low stock alerts are based on the threshold values set for each feed type. 
                Estimated days remaining are calculated based on average usage over the past 30 days, if available.</p>
            </div>
        </div>`;

        return html;
    }

    // Helper function to estimate days remaining based on recent usage
    function estimateDaysRemaining(item, data) {
        const feedType = item.feedType;
        const currentQuantity = parseFloat(item.quantity) || 0;
        
        // Get recent usage data (last 30 days)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        // Extract feed transactions from the data object
        const feedTransactions = data && data.feedTransactions ? data.feedTransactions : 
                               (data && Array.isArray(data.allTransactions) ? data.allTransactions : []);
        
        // Filter to get only usage transactions for this feed type in the last 30 days
        const recentUsage = feedTransactions.filter(usage => 
            usage.feedType === feedType && 
            usage.type === 'usage' &&
            new Date(usage.date) >= thirtyDaysAgo
        );
        
        if (recentUsage.length === 0) {
            return null; // No recent usage data
        }
        
        // Calculate average daily usage
        const totalUsed = recentUsage.reduce((sum, usage) => sum + (parseFloat(usage.quantity) || 0), 0);
        const avgDailyUsage = totalUsed / 30;
        
        if (avgDailyUsage === 0) {
            return null; // No usage
        }
        
        // Estimate days remaining
        return currentQuantity / avgDailyUsage;
    }

    // Helper function to get feed category
    function getFeedCategory(feedType) {
        // This is a simplified version - should be replaced with actual categorization logic
        if (!feedType) return 'Other';
        
        if (feedType.toLowerCase().includes('chick')) return 'Poultry';
        if (feedType.toLowerCase().includes('broiler')) return 'Poultry';
        if (feedType.toLowerCase().includes('layer')) return 'Poultry';
        if (feedType.toLowerCase().includes('poultry')) return 'Poultry';
        
        if (feedType.toLowerCase().includes('pig')) return 'Swine';
        if (feedType.toLowerCase().includes('hog')) return 'Swine';
        if (feedType.toLowerCase().includes('sow')) return 'Swine';
        
        if (feedType.toLowerCase().includes('cow')) return 'Cattle';
        if (feedType.toLowerCase().includes('cattle')) return 'Cattle';
        if (feedType.toLowerCase().includes('dairy')) return 'Cattle';
        
        if (feedType.toLowerCase().includes('goat')) return 'Small Ruminants';
        if (feedType.toLowerCase().includes('sheep')) return 'Small Ruminants';
        
        return 'Other';
    }
    
    /**
     * Export report data to CSV
     */
    function exportReportToCSV(reportType) {
        // Get the table element - first table in the report-content div
        const table = document.querySelector('.report-content table');
        if (!table) {
            console.error('No table found for CSV export');
            alert('No data available to export.');
            return;
        }
        
        // Extract headers
        const headers = [];
        const headerRow = table.querySelector('thead tr');
        if (headerRow) {
            headerRow.querySelectorAll('th').forEach(th => {
                headers.push(th.textContent.trim());
            });
        }
        
        // Extract rows
        const rows = [];
        table.querySelectorAll('tbody tr').forEach(tr => {
            // Skip month separator rows if they exist
            if (tr.classList.contains('month-separator')) {
                return;
            }
            
            const row = [];
            tr.querySelectorAll('td').forEach(td => {
                // Clean cell value - replace commas to avoid CSV parsing issues
                let cellValue = td.textContent.trim().replace(/,/g, ';');
                row.push(cellValue);
            });
            
            if (row.length > 0) {
                rows.push(row);
            }
        });
        
        // Create CSV content
        let csvContent = headers.join(',') + '\n';
        rows.forEach(row => {
            csvContent += row.join(',') + '\n';
        });
        
        // Prepare file name based on report type and current date
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        const fileName = `${reportType.replace('-', '_')}_report_${dateStr}.csv`;
        
        // Create download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', fileName);
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log(`Report exported to CSV: ${fileName}`);
    }

    // Make exportReportToCSV available globally
    window.exportReportToCSV = exportReportToCSV;
    
});  // Close for document.addEventListener('DOMContentLoaded', async () => {

// Add helper functions that can be called from anywhere

/**
 * Format a date in a user-friendly format
 */
function formatDate(dateString) {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    return date.toLocaleDateString();
}

/**
 * Gets animal categories from storage
 */
    async function getAnimalCategories() {
        const categoriesStr = await mobileStorage.getItem('animalCategories');
    return categoriesStr ? JSON.parse(categoriesStr) : [];
}

/**
 * Gets the most recent feed prices
 */
async function getMostRecentFeedPrices() {
    try {
        const feedTransactionsStr = await mobileStorage.getItem('feedTransactions');
        const feedTransactions = feedTransactionsStr ? JSON.parse(feedTransactionsStr) : [];
        
        // Create a Map to store the most recent price for each feed type
        const priceMap = new Map();
        
        // Process only purchase transactions
        feedTransactions
            .filter(t => t.type === 'purchase' && t.feedType && (t.pricePerUnit || t.totalPrice))
            .forEach(transaction => {
                const feedType = transaction.feedType;
                const pricePerUnit = transaction.pricePerUnit || 
                                    (transaction.totalPrice && transaction.quantity ? 
                                     transaction.totalPrice / transaction.quantity : 0);
                
                if (!priceMap.has(feedType) || 
                    new Date(transaction.date) > new Date(priceMap.get(feedType).date)) {
                    priceMap.set(feedType, {
                        date: transaction.date,
                        pricePerUnit: pricePerUnit
                    });
                }
            });
        
        return priceMap;
    } catch (error) {
        console.error('Error getting recent feed prices:', error);
        return new Map();
    }
}

/**
 * Setup the debug panel for mobile debugging
 */
function setupDebugPanel() {
    console.log('Debug panel initialized');
    
    // Override console.log to output to debug panel as well
    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;
    
    console.log = function() {
        const args = Array.from(arguments);
        originalConsoleLog.apply(console, args);
        
        // Add to debug log if panel exists
        const debugLog = document.getElementById('debugLog');
        if (debugLog) {
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg);
            } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `[${timestamp}] [INFO] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
    };
    
    console.error = function() {
        const args = Array.from(arguments);
        originalConsoleError.apply(console, args);
        
        // Add to debug log if panel exists
        const debugLog = document.getElementById('debugLog');
        if (debugLog) {
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg);
                    } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'error-log';
            logEntry.innerHTML = `[${timestamp}] [ERROR] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
    };
    
    console.warn = function() {
        const args = Array.from(arguments);
        originalConsoleWarn.apply(console, args);
        
        // Add to debug log if panel exists
        const debugLog = document.getElementById('debugLog');
        if (debugLog) {
            const message = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg);
            } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'warning-log';
            logEntry.innerHTML = `[${timestamp}] [WARN] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
    };
}

/**
 * Collect filters from the form
 */
function collectFilters() {
    console.log('collectFilters - current values:', {
        selectedReportType,
        selectedMainType
    });
    
    return {
        reportType: selectedReportType,
        mainType: selectedMainType,
        category: document.getElementById('category-filter').value,
        dateRange: {
            start: document.getElementById('date-from').value,
            end: document.getElementById('date-to').value
        }
    };
}

/**
 * Collect report data based on filters
 */
async function collectReportData(filters) {
    console.log('collectReportData called with filters:', filters);
    
    // Return empty array if no report type or date range
    if (!filters || !filters.reportType || !filters.dateRange) {
        console.log('Missing required filters');
        return [];
    }
    
    try {
        // Convert date strings to Date objects for comparison
        const startDate = new Date(filters.dateRange.start);
        const endDate = new Date(filters.dateRange.end);
        
        // Add one day to end date to include the end date in results
        endDate.setDate(endDate.getDate() + 1);
        
        console.log(`Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);
        
        // Load data based on report type
        switch (filters.reportType) {
            case 'all-feed':
                return await loadAllFeedReportData(startDate, endDate, filters.category);
                
            case 'feed-purchase':
                return await loadFeedPurchaseData(startDate, endDate, filters.category);
                
            case 'feed-usage':
                return await loadFeedUsageData(startDate, endDate, filters.category);
                
            case 'feed-calculation':
                // For feed calculations, we don't need to fetch data from storage
                // as we're using mock data in the handleFeedCalculations function
                return null;
                
            case 'feed-inventory':
                return await loadFeedInventoryData(startDate, endDate, filters.category);
                
            default:
                console.warn(`Unsupported report type: ${filters.reportType}`);
                return [];
        }
    } catch (error) {
        console.error('Error collecting report data:', error);
        return [];
    }
}

/**
 * Load all feed-related data
 */
async function loadAllFeedReportData(startDate, endDate, category) {
    console.log('Loading all feed report data');
    
    // Load feed transactions from storage
    const feedTransactionsStr = await mobileStorage.getItem('feedTransactions');
    const feedTransactions = feedTransactionsStr ? JSON.parse(feedTransactionsStr) : [];
    
    // Filter by date range
    const filteredTransactions = feedTransactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transactionDate >= startDate && transactionDate <= endDate;
    });
    
    // Filter by category if specified
    const categoryFiltered = category === 'all' ? 
        filteredTransactions : 
        filteredTransactions.filter(t => t.feedType === category);
    
    console.log(`Found ${categoryFiltered.length} feed transactions in date range`);
    return categoryFiltered;
}

/**
 * Load feed purchase data
 */
async function loadFeedPurchaseData(startDate, endDate, category) {
    console.log('Loading feed purchase data');
    
    // Load feed transactions from storage
    const feedTransactionsStr = await mobileStorage.getItem('feedTransactions');
    const feedTransactions = feedTransactionsStr ? JSON.parse(feedTransactionsStr) : [];
    
    // Filter by date range and type
    const filteredTransactions = feedTransactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transactionDate >= startDate && 
               transactionDate <= endDate && 
               transaction.type === 'purchase';
    });
    
    // Filter by category if specified
    const categoryFiltered = category === 'all' ? 
        filteredTransactions : 
        filteredTransactions.filter(t => t.feedType === category);
    
    console.log(`Found ${categoryFiltered.length} feed purchases in date range`);
    return categoryFiltered;
}

/**
 * Load feed usage data
 */
async function loadFeedUsageData(startDate, endDate, category) {
    console.log('Loading feed usage data');
    
    // Load feed transactions from storage
    const feedTransactionsStr = await mobileStorage.getItem('feedTransactions');
    const feedTransactions = feedTransactionsStr ? JSON.parse(feedTransactionsStr) : [];
    
    // Filter by date range and type
    const filteredTransactions = feedTransactions.filter(transaction => {
        const transactionDate = new Date(transaction.date);
        return transactionDate >= startDate && 
               transactionDate <= endDate && 
               transaction.type === 'usage';
    });
    
    // Find all purchase transactions to calculate missing costs
    const purchaseTransactions = feedTransactions.filter(t => t.type === 'purchase');
    
    // Map of feed types to their most recent purchase price
    const feedPrices = new Map();
    
    // Get most recent purchase prices for each feed type
    purchaseTransactions.forEach(purchase => {
        const feedType = purchase.feedType;
        if (!feedType) return;
        
        // Calculate the price per unit if not directly provided
        let pricePerUnit = purchase.pricePerUnit;
        if (!pricePerUnit && purchase.totalPrice && purchase.quantity) {
            pricePerUnit = purchase.totalPrice / purchase.quantity;
        }
        
        if (!pricePerUnit) return;
        
        // Store or update the price for this feed type
        if (!feedPrices.has(feedType) || 
            new Date(purchase.date) > new Date(feedPrices.get(feedType).date)) {
            feedPrices.set(feedType, {
                date: purchase.date,
                pricePerUnit: pricePerUnit
            });
        }
    });
    
    // Add cost data to usage transactions where missing
    filteredTransactions.forEach(usage => {
        // Skip if already has cost data
        if (usage.totalCost || usage.cost) return;
        
        const feedType = usage.feedType;
        const quantity = usage.quantity;
        
        // Skip if missing essential data
        if (!feedType || !quantity) return;
        
        // Get price data for this feed type
        const priceData = feedPrices.get(feedType);
        if (priceData) {
            // Calculate cost based on most recent purchase price
            usage.totalCost = quantity * priceData.pricePerUnit;
            usage.priceSource = 'calculated';  // Flag that this was calculated
        }
    });
    
    // Filter by category if specified
    const categoryFiltered = category === 'all' ? 
        filteredTransactions : 
        filteredTransactions.filter(t => t.feedType === category);
    
    console.log(`Found ${categoryFiltered.length} feed usage records in date range`);
    
    // Return the usage records along with all feed transactions for cost calculations
    return {
        feedTransactions: categoryFiltered,
        allTransactions: feedTransactions
    };
}

/**
 * Load feed inventory data
 */
async function loadFeedInventoryData(startDate, endDate, category) {
    console.log('Loading feed inventory data');
    
    // For inventory, we'll return current stock levels
    // Start by loading the feed inventory
    const feedInventoryStr = await mobileStorage.getItem('feedInventory');
    let feedInventoryData = feedInventoryStr ? JSON.parse(feedInventoryStr) : [];
    
    // Convert from the Map entries format (array of [key, value] pairs)
    let inventoryArray = [];
    
    if (Array.isArray(feedInventoryData)) {
        // This is the new format: array of [key, value] pairs from Map.entries()
        const feedInventory = new Map(feedInventoryData);
        
        // Convert Map to array of objects for reporting
        for (const [feedType, data] of feedInventory.entries()) {
            inventoryArray.push({
                feedType: feedType,
                quantity: data.quantity || 0,
                unit: data.unit || 'kg',
                price: data.price || 0,
                weightPerKg: data.weightPerKg || 0,
                threshold: data.threshold || 0,
                supplier: data.supplier || '',
                lastUpdated: data.lastUpdated || new Date().toISOString()
            });
        }
    } else {
        // Legacy format (object)
        for (const feedType in feedInventoryData) {
            inventoryArray.push({
                feedType: feedType,
                quantity: feedInventoryData[feedType],
                unit: 'kg' // Default unit
            });
        }
    }
    
    // Filter by category if specified
    const categoryFiltered = category === 'all' ? 
        inventoryArray : 
        inventoryArray.filter(item => item.feedType === category);
    
    console.log(`Found ${categoryFiltered.length} feed inventory items`);
    return categoryFiltered;
}
    
// Add a helper function to estimate weights based on feed types
function getEstimatedWeight(feedType) {
    // Common feed weights - these are estimates only when no user data is available
    const feedTypeWeights = {
        'Hay': 20,  // ~20kg per bale
        'Straw': 15, // ~15kg per bale
        'Lucerne': 25, // ~25kg per bale
        'Maize': 40, // ~40kg per bag
        'Wheat': 50, // ~50kg per bag
        'Bran': 30,  // ~30kg per bag
        'Concentrate': 40, // ~40kg per bag
        'Lick': 25,  // ~25kg per bag
        'Mineral': 25, // ~25kg per bag
        'Winter Lick': 50, // ~50kg per bag
        'Summer Lick': 50, // ~50kg per bag
        'Production Lick': 50 // ~50kg per bag
    };
    
    // Try to find a match based on feed type name
    for (const [knownType, weight] of Object.entries(feedTypeWeights)) {
        if (feedType.toLowerCase().includes(knownType.toLowerCase())) {
            return weight;
        }
    }
    
    // Default to a conservative estimate if no match
    return 25; // 25kg is a conservative default
}
    
// Add a function to format weight values consistently
function formatWeight(weightInKg) {
    if (!weightInKg && weightInKg !== 0) return '-';
    
    // Format based on magnitude
    if (weightInKg >= 1000) {
        return `${(weightInKg / 1000).toFixed(2)} tonnes`;
    } else {
        return `${weightInKg.toFixed(2)} kg`;
    }
}
    
/**
 * Handle feed calculations report
 */
function handleFeedCalculations() {
    try {
        console.log('handleFeedCalculations called');
        
        // Get selected date range
        const startDate = document.getElementById('date-from').value;
        const endDate = document.getElementById('date-to').value;
        
        console.log('Feed calculations date range:', startDate, 'to', endDate);
        
        if (!startDate || !endDate) {
            console.log('Missing date range for feed calculations');
            return '<div class="alert alert-warning">Please select a date range</div>';
        }
        
        // Mock feed calculation data based on user's example
        const feedCalculations = [
            {
                animalType: 'Cull Cows',
                count: 1,
                date: '3/25/2025',
                feedType: 'Production Lick',
                dailyIntake: 1.20,
                intakeUnit: 'kg',
                totalFeed: 144.00,
                duration: 120,
                dailyCost: 7.68,
                costPerAnimal: 7.68,
                totalCost: 921.60
            },
            {
                animalType: 'Cows',
                count: 1,
                date: '3/25/2025',
                feedType: 'Winter Lick',
                dailyIntake: 0.50,
                intakeUnit: 'kg',
                totalFeed: 60.00,
                duration: 120,
                dailyCost: 2.80,
                costPerAnimal: 2.80,
                totalCost: 336.00
            }
        ];
        
        console.log('Feed calculations mock data prepared:', feedCalculations.length, 'records');
        
        // Build HTML report
        let html = `
            <div class="report-header">
                <div class="report-type-header">
                    <div class="report-type-title">Feed Calculations Report</div>
                    <div class="report-actions">
                        <button onclick="window.print()" class="print-button">Print Report</button>
                        <button onclick="exportReportToCSV('feed-calculations')" class="export-button">Export to CSV</button>
                    </div>
                </div>
                <div class="report-summary">
                    <p>Report date range: ${formatDate(startDate)} to ${formatDate(endDate)}</p>
                    <p>Total number of calculations: ${feedCalculations.length}</p>
                    <p>Total feed cost: ${formatCurrency(feedCalculations.reduce((sum, calc) => sum + calc.totalCost, 0))}</p>
                </div>
            </div>
            
            <div class="report-section">
                <h3>Feed Calculations</h3>
        `;
        
        // Generate calculation cards
        feedCalculations.forEach(calc => {
            html += `
                <div class="calculation-card feed-calculation-card">
                    <div class="card-header">
                        <h4>${calc.animalType} (${calc.count} animals)</h4>
                        <div class="calculation-date">${formatDate(calc.date)}</div>
                    </div>
                    <div class="card-body">
                        <div class="feed-details">
                            <p><strong>Feed:</strong> ${calc.feedType}</p>
                            <p><strong>Daily intake:</strong> ${calc.dailyIntake.toFixed(2)}${calc.intakeUnit} per animal</p>
                            <p><strong>Total feed:</strong> ${calc.totalFeed.toFixed(2)}${calc.intakeUnit} (${calc.duration} days)</p>
                        </div>
                        <div class="cost-details">
                            <p><strong>Daily cost:</strong> ${formatCurrency(calc.dailyCost)}</p>
                            <p><strong>Per animal:</strong> ${formatCurrency(calc.costPerAnimal)}/day</p>
                            <p><strong>Total (${calc.duration} days):</strong> ${formatCurrency(calc.totalCost)}</p>
                        </div>
                    </div>
                </div>
            `;
        });
        
        // Add summary table
        html += `
            <h3>Summary Table</h3>
            <table class="report-table">
                <thead>
                    <tr>
                        <th>Animal Type</th>
                        <th>Count</th>
                        <th>Feed Type</th>
                        <th>Daily Intake</th>
                        <th>Total Feed</th>
                        <th>Duration</th>
                        <th>Daily Cost</th>
                        <th>Cost per Animal</th>
                        <th>Total Cost</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        feedCalculations.forEach(calc => {
            html += `
                <tr>
                    <td>${calc.animalType}</td>
                    <td>${calc.count}</td>
                    <td>${calc.feedType}</td>
                    <td>${calc.dailyIntake.toFixed(2)}${calc.intakeUnit}</td>
                    <td>${calc.totalFeed.toFixed(2)}${calc.intakeUnit}</td>
                    <td>${calc.duration} days</td>
                    <td>${formatCurrency(calc.dailyCost)}</td>
                    <td>${formatCurrency(calc.costPerAnimal)}/day</td>
                    <td>${formatCurrency(calc.totalCost)}</td>
                </tr>
            `;
        });
        
        // Add totals row
        const totalCost = feedCalculations.reduce((sum, calc) => sum + calc.totalCost, 0);
        html += `
                <tr class="total-row">
                    <td colspan="8" class="text-right"><strong>Total Cost:</strong></td>
                    <td>${formatCurrency(totalCost)}</td>
                </tr>
            </tbody>
            </table>
            
            <div class="report-notes">
                <h4>Notes:</h4>
                <ul>
                    <li>Feed calculations are based on standard nutritional requirements for each animal type.</li>
                    <li>Costs are calculated using current feed prices stored in the system.</li>
                    <li>Actual consumption may vary based on animal health, weather conditions, and other factors.</li>
                </ul>
            </div>
        </div>
        `;
        
        console.log('Feed calculations HTML generated successfully');
        return html;
    } catch (error) {
        console.error('Error in feed calculations:', error);
        return `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}
    